# Elastic Grid Network?
*Elastic Grid Network*는 *브릴라이트 플랫폼*의 *P2P 그리드 네트워킹 솔루션*입니다.  

*브릴라이트 플랫폼*에서는 블록의 합의를 위해 마이닝 권한을 가진 모든 노드가 동시에 통신을 하여 합의에 이르러야 합니다. 모든 마이닝 노드가 합의에 참여하기 때문에, 체인에 연결된 블록은 되돌릴 수 없는 비가역적인 상태가 되며, 이를 통해 *더블 스펜딩 문제*를 해결할 수 있고, *컨펌 타임*을 기다릴 필요 없이 즉각적으로 거래의 확정이 가능해집니다.  

그러나, 모든 마이닝 노드가 합의에 참여한다는 것은, 네트워크에 참여하고 있는 노드의 수가 증가할수록 네트워크 전송 부담이 커져 제한 시간 내에 합의에 도달하지 못할 수도 있는 위험을 내포하게 됩니다. 가령, 브릴라이트 네트워크에 참여하고 있는 마이닝 노드가 약 1만개이고, BCP 합의 과정에서 검증할 블록의 크기가 1MB라고 가정해 봅시다. 이 경우, 블록 검증을 요청하는 노드가 전송해야 하는 데이터는 약 `10GB(1MB * 10,000)`이며, BCP 제한 시간 이내에 모든 노드에 블록을 전송하고 검증하여 합의에 도달하기가 어렵습니다.  

이러한 문제를 해결하기 위해 *브릴라이트 플랫폼*에 적합한 형태의 *Elastic Grid Network Solution*을 고안하게 되었고, 이 솔루션은 네트워크에 참여하고 있는 마이닝 노드의 규모에 따라 그리드의 레이아웃이 탄력적으로 적용되는 효율적인 그리드 네트워크 기술입니다.  

# Notice
이 프로젝트 및 코드는 *Elastic Grid Network Protocol*이 어떻게 동작하는지 보여주는 컨셉 코드이며, 
*브릴라이트 플랫폼*의 실제 코드가 아닙니다.

# 개발 환경
* Visual Studio 2017 
* [.NET Core 2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2)

# Elastic Grid Network 동작 기본 원리
네트워크에 참여하고 있는 마이닝 노드는 *Node Discovery Service*를 통해( 여기서는 `PeerListServiceApp` ) 네트워크에 참여중인 모든 마이닝 노드의 주소를 알고 있습니다.  

하나의 노드가 전체 네트워크에 메세지를 전송하고자 하는 경우,

* 전송자는 네트워크에 참여하고 있는 마이닝 노드 규모에 따라 그리드의 `layout`을 결정합니다.
레이아웃은 (x, y, z)의 3차원 좌표계로 표현됩니다. ( 예: layout={3, 3, 3} )  
(참고: [노드의 좌표 계산](#노드의-좌표-계산))
      
* 결정된 레이아웃으로 부터 각각의 노드 좌표가 자동으로 결정됩니다.  
(참고: [참여 마이닝 노드 수에 따른 레이아웃의 결정](#참여-마이닝-노드-수에-따른-레이아웃의-결정))

* 전송자는 그리드에 속한 노드 중 하나의 노드를 랜덤하게 선택하여 해당 노드에 메세지를 전송하고, 
이 메세지를 수신한 수신자는 해당 그리드의 모든 노드에게 메세지를 중계합니다.
그리드에 속한 노드 중 하나의 노드를 선택하는 과정에서 전송자가 그리드에 포함되어 있는 경우에는 항상 전송자를 선택합니다.
선택한 노드로 메세지 전송이 실패하는 경우, 다음 노드를 선택하여 다시 전송합니다.

* 레이아웃에 따라, Z-축, Y-축, X-축 순으로 중계가 이루어집니다.  
(참고: [메세지 브로드 캐스트 동작 과정](#메세지-브로드-캐스트-동작-과정))

# 참여 마이닝 노드 수에 따른 레이아웃의 결정
레이아웃은 전송자가 메세지를 전송할 때 결정하며, 전체 네트워크에 참여중인 노드의 수 `nPeers`와 하나의 그리드에 포함할 노드의 수 `N`에 의해 결정됩니다.
> N: 하나의 그리드에 포함할 노드의 수  
> nPeers: 네트워크에 참여중인 전체 노드의 수

아래의 그림은 현재 네트워크에 참여중인 전체 노드의 수 `nPeers`와 그리드에 포함할 노드의 수 `N`값에 따른 레이아웃의 결정 과정을 보여주고 있습니다.

![nPeers<=N^2](https://user-images.githubusercontent.com/38033465/53714769-f64e8880-3e92-11e9-85b8-eed71251081f.jpg)
![nPeers<=N^4](https://user-images.githubusercontent.com/38033465/53714772-f8184c00-3e92-11e9-9cea-21d680406164.jpg)

위 그림의 각각의 박스에는 약 `N`개의 노드가 분포합니다.

# 노드의 좌표 계산
노드의 주소를 해시한 값으로 부터 각각 `hx`, `hy`, `hz` 값을 추출하여 레이아웃의 각 좌표축 크기로 나머지 연산을 한 결과로 노드의 좌표가 결정됩니다.

![hx,hy,hz](https://user-images.githubusercontent.com/38033465/53714789-11b99380-3e93-11e9-9a5f-aeb94da44145.jpg)

~~~
CoordinateOf(Node).X = 1 + ( hx % layout.X )
CoordinateOf(Node).Y = 1 + ( hy % layout.Y )
CoordinateOf(Node).Z = 1 + ( hz % layout.Z )
~~~

이 좌표는 노드의 주소와 레이아웃에 의해 `결정적(Deterministic)` 특성을 가지며, 각각의 레이아웃에 균일하게 분표합니다.

# 메세지 브로드 캐스트 동작 과정

전체 참여 노드가 `81`개이고, 레이아웃이 `{3, 3, 3}`인 경우를 예로 들어 다음과 같이 메세지 브로드 캐스팅을 표현할 수 있습니다. 아래 그림의 하나의 박스에는 약 `3`개의 노드가 포함되어 있다고 할 수 있습니다.

## Z-축 메세지 전송
레이아웃의 Z축의 크기가 1보다 큰 경우, 아래 그림과 같이 전체 노드를 Z축으로 분할하여, 각각의 좌표로 메세지를 중계합니다.

![broadcast-x](https://user-images.githubusercontent.com/38033465/53714872-64934b00-3e93-11e9-8891-324a07810bec.jpg)

* z축 좌표가 1인 모든 노드 중 하나의 노드를 랜덤하게 선택하여 메세지를 전송합니다. ( 이 경우는 전송자가 포함되어 있기 때문에, 전송자를 선택하여 메세지를 전송합니다. )
* z축 좌표가 2인 모든 노드 중 하나의 노드를 랜덤하게 선택하여 메세지를 전송합니다. 
* Z축 좌표가 3인 모든 노드 중 하나의 노드를 랜덤하게 선택하여 메세지를 전송합니다.
* 이 메세지를 수신한 노드는 아래의 [Y-축 메세지 전송](#Y-축-메세지-전송)과 같은 방식으로 Y축으로 메세지를 중계합니다.

## Y-축 메세지 전송
레이아웃의 Y축의 크기가 1보다 큰 경우, 아래 그림과 같이 전체 노드를 Y축으로 분할하여, 각각의 좌표로 메세지를 중계합니다. Z-축 메세지 전송을 통해 수신한 메세지를 Y-축으로 중계하려고 하는 경우에는 전체 노드의 범위가 해당 Z-축 좌표로 한정됩니다.

![broadcast-y](https://user-images.githubusercontent.com/38033465/53714875-665d0e80-3e93-11e9-8dda-a0cdd647b942.jpg)

* y축 좌표가 1인 모든 노드 중 하나의 노드를 랜덤하게 선택하여 메세지를 전송합니다. 
* y축 좌표가 2인 모든 노드 중 하나의 노드를 랜덤하게 선택하여 메세지를 전송합니다. ( 이 경우는 전송자가 포함되어 있기 때문에, 전송자를 선택하여 메세지를 전송합니다. )
* y축 좌표가 3인 모든 노드 중 하나의 노드를 랜덤하게 선택하여 메세지를 전송합니다.
* 이 메세지를 수신한 노드는 아래의 [X-축 메세지 전송](#X-축-메세지-전송)과 같은 방식으로 X축으로 메세지를 중계합니다.

## X-축 메세지 전송
레이아웃의 X축의 크기가 1보다 큰 경우, 아래 그림과 같이 전체 노드를 X축으로 분할하여, 각각의 좌표로 메세지를 중계합니다. Y-축 메세지 전송을 통해 수신한 메세지를 X-축으로 중계하려고 하는 경우에는 전체 노드의 범위가 해당 Y-축, Z-축 좌표로 한정됩니다.

![broadcast-z](https://user-images.githubusercontent.com/38033465/53714883-6826d200-3e93-11e9-8ecb-8507a9a81af4.jpg)

* x축 좌표가 1인 모든 노드 중 하나의 노드를 랜덤하게 선택하여 메세지를 전송합니다.
* x축 좌표가 2인 모든 노드 중 하나의 노드를 랜덤하게 선택하여 메세지를 전송합니다. ( 이 경우는 전송자가 포함되어 있기 때문에, 전송자를 선택하여 메세지를 전송합니다. )
* x축 좌표가 3인 모든 노드 중 하나의 노드를 랜덤하게 선택하여 메세지를 전송합니다.
* 이 메세지를 수신한 노드는 해당 좌표에 소속된 모든 노드에게 메세지를 전송합니다. 이 과정에서 전체 노드에게 메세지가 전달 완료됩니다.

## Coverage

* 전송자는 `N * 4`번의 Send() 호출을 통해 `N ^ 4`개의 노드에게 메세지를 전송할 수 있습니다.  
`N = 8`인 경우, 약 `32`번의 Send() 호출을 통해 `4,096`개의 노드에게 메세지를 전송할 수 있습니다.  
`N = 16`인 경우, 약 `64`번의 Send() 호출을 통해 `65,536`개의 노드에게 메세지를 전송할 수 있습니다.  
`N = 32`인 경우, 약 `128`번의 Send() 호출을 통해 `1,048,576`개의 노드에게 메세지를 전송할 수 있습니다.  
* 만약, 필요하다면 ( x, y, z, w )의 4차원 좌표계로 확장할 수도 있습니다.  
이 경우 전송자는 `N * 5`번의 Send() 호출을 통해 `N ^ 5`개의 노드에게 메세지를 전송할 수 있을 것입니다.

# 데모
* Windows x64 기반의 데모 실행파일이 `Demo/win-x64` 폴더에 제공됩니다.  
* `PeerListServiceApp.exe` : 노드 디스커버리 서비스와 같은 Peer 목록 동기화 서비스 입니다.  
* `ElasticNodeServiceApp.exe` : Elastic Grid Network 메세지 전송을 수행하는 P2P 노드 서비스 입니다. ( nPeers 만큼 프로세스가 포크됩니다. )  
* `Demo/win-x64` 경로에서 `demo.bat` 를 실행하세요.  
( [.NET Core 2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2) 가 설치되어 있어야 하고, `dotnet.exe`가 존재하는 폴더(`C:\Program Files\dotnet\`)가 `PATH`에 등록되어 있어야 합니다. )  
* `PeerListServiceApp.exe` 콘솔창과 `ElasticNodeServiceApp.exe` 콘솔창이 실행되면, `ElasticNodeServiceApp.exe` 콘솔창에 `test.start()` 를 입력하여 테스트를 실행할 수 있습니다.  
기본 환경 설정 값으로 `n=8`, `nPeers=32`, `msgKBytes=128`, `nTimes=10` 으로 설정되어 있습니다.  
테스트를 실행하기 전에 `set(n,16)`, `set(nPeers,64)`, `set(msgKBytes,256)`, `set(nTimes,20)` 과 같이 콘솔 창에 입력하여 환경 설정 값을 변경할 수 있습니다.  

![elasticnodeserviceapp_demo_screenshot](https://user-images.githubusercontent.com/39185929/57013410-60db3500-6c46-11e9-9ccb-986419a5c1b1.png)

# 테스트 보고서

![TEST_RESULT](https://user-images.githubusercontent.com/39185929/57013490-b7e10a00-6c46-11e9-9092-40b5842125c4.png)

**테스트 환경**

* Windows 10 x64, .NET Core 2.2
* Intel Core i7-8700K 3.70GHz, 6 core, 12 logical processor
* 64GB DDR4
